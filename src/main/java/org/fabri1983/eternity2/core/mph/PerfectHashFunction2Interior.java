package org.fabri1983.eternity2.core.mph;

/**
 * This class generated manually from the output algorithm in phash.c produced by the 
 * Bob Jenkins' Minimal Perfect Hash function algorithm, taking as input the misc/super_matriz_decimal.txt file.
 * See README.md file on how to generate that function.
 * 
 * PHASHRANGE - 1 is the greatest value produced by phash(), for the number of provided keys, which means super_matriz[] size must be PHASHRANGE.
 */
public class PerfectHashFunction2Interior {

	public static final int PHASHRANGE = 8192;
	
	// PHASHLEN 0x200 = 512
	static short tab[] = { 6321, 5355, 6184, 4055, 0, 0, 5890, 3921, 6849, 5325, 5512, 3545, 7452, 6141, 4755, 8065,
			3975, 6856, 5586, 3313, 1533, 4368, 7992, 844, 4099, 6029, 2139, 5317, 3017, 2918, 6321, 7733, 2191, 7856,
			3507, 5779, 3507, 5389, 416, 3304, 3452, 131, 3969, 6283, 1232, 896, 6982, 6383, 7086, 1766, 287, 6863,
			4230, 7592, 4400, 3669, 183, 7452, 7412, 1403, 5522, 540, 1057, 5963, 3969, 7452, 4306, 8180, 2937, 5663,
			7848, 5389, 3561, 0, 2191, 2055, 6799, 4986, 5355, 4942, 4813, 4672, 2517, 3625, 3975, 6352, 7059, 922,
			6847, 6103, 6419, 5516, 3816, 0, 218, 330, 0, 5325, 5499, 7452, 3325, 3822, 2400, 6026, 6878, 2139, 3969,
			1905, 6873, 2478, 1524, 5225, 5862, 5586, 3229, 5769, 5930, 4064, 6675, 592, 4642, 7877, 6689, 2021, 8070,
			843, 3579, 1905, 6322, 6788, 3155, 6999, 3507, 1968, 7017, 2185, 3155, 1538, 6669, 5345, 1403, 0, 7084,
			6178, 131, 6849, 4600, 7425, 7622, 6675, 3290, 3921, 998, 1729, 3879, 6601, 5000, 8034, 4164, 6904, 100,
			3822, 7452, 1533, 6352, 3204, 1334, 3685, 5220, 1905, 6675, 1810, 6743, 3499, 3969, 1403, 6110, 416, 3959,
			522, 2320, 4401, 1785, 896, 5544, 2517, 5357, 5917, 4303, 7588, 6604, 3845, 2093, 4974, 5389, 3933, 3056,
			5562, 592, 3584, 1403, 0, 2269, 5628, 4262, 2454, 4927, 7733, 6528, 1810, 1041, 5452, 2987, 6383, 2028,
			3802, 7516, 5218, 3083, 3579, 1227, 2673, 3049, 3303, 998, 3921, 322, 1825, 2400, 5890, 4099, 1814, 6921,
			30, 1896, 322, 2139, 4755, 6103, 7322, 2478, 6137, 2572, 2209, 2280, 6263, 8044, 3950, 5978, 4564, 5057,
			3509, 6847, 254, 4541, 8056, 1785, 2981, 7745, 628, 5985, 1210, 5534, 522, 6675, 3155, 5359, 508, 6141,
			4400, 4171, 3712, 5129, 16, 7856, 3210, 6383, 4600, 3304, 7017, 218, 5345, 7414, 7084, 3366, 3545, 7412,
			6624, 1896, 6249, 5311, 5811, 1338, 7322, 8190, 5018, 1810, 8015, 7452, 1480, 578, 2199, 522, 3509, 2794,
			4415, 6601, 7622, 8070, 1403, 1449, 2918, 2442, 5220, 357, 3056, 3991, 2844, 423, 2209, 157, 7516, 2932,
			1810, 6178, 7134, 2517, 1858, 3155, 1428, 6503, 3083, 2794, 3509, 3056, 3290, 7452, 5512, 4491, 5743, 4228,
			5294, 1723, 2001, 3083, 3822, 6528, 3049, 5562, 5389, 3879, 6299, 3933, 2171, 3109, 1446, 6265, 5774, 3850,
			1968, 4207, 7992, 4986, 2110, 8065, 7560, 6029, 1785, 1679, 3210, 6322, 1403, 2653, 1570, 5831, 6008, 183,
			7579, 4974, 3451, 523, 7555, 330, 3842, 2139, 2209, 7156, 4600, 1334, 3822, 4055, 6743, 6557, 5615, 7297,
			5534, 8180, 992, 1480, 5930, 0, 2918, 2616, 4280, 2518, 6999, 7108, 669, 6383, 223, 4262, 1403, 1905, 6675,
			6184, 7966, 922, 341, 4491, 4400, 7798, 5218, 2280, 5522, 1057, 747, 4306, 3222, 6322, 7856, 218, 955, 4813,
			414, 7646, 2794, 3950, 5463, 2870, 12, 1607, 5917, 1968, 1210, 1041, 3325, 2820, 6029, 1199, 7051, 7891,
			254, 322, 5345, 7006, 3380, 922, 642, 7668, 706, 2191, 6177, 7942, 2790, 7250, 562, 7525, 1810, 2442, 7086,
			6503, 7856, 6849, 0, 6847, 1403, 2465, 5127, 6666, 3204, 508, 896, 4942, 5628, 5769, 2110, 3210, 0, 3380,
			7733, 6636, 5862, 7155, 4600, 7081, 6895, 4344, 6669, 2191, 3210, 2185, 1428, 508, 1905, 4927, 1751, 1810,
			7452, 1480, 6321, 1538, 4115 };

	public static int phash(int val) {
		// NOTE: in Java remember to replace >> by >>> to avoid carrying out the bit sign when you know some operations exceed 2^31 - 1
		// I decided to use >>> to always avoid carrying out the sign.
		
		val += 0xdc6d87dd; // PHASHSALT 0xdc6d87dd (31 bits!)
		val ^= (val >>> 16);
		
		/**
		 * IMPORTANT: val += (val << 8)
		 *  val << 8   This exceeds 31 bits for some values of val, and I suspect is down casted to int losing higher 32+ bits (if no later on).
		 *  val += ... This sum and assignment exceeds 31 bits as per before, and might be down casted twice: first at sum result and then at assignment step.
		 * 
		 * However this behavior works fine and produces correct results.
		 */
		val += (val << 8);
		
		val ^= (val >>> 4);
		int b = (val >>> 8) & 0x1ff; // 0x1ff = 511 => & 0x1ff is the fastest way of doing % 0x200 (PHASHLEN 512)
		int a = (val + (val << 2)) >>> 19;
		int rsl = (a ^ tab[b]);
		return rsl; // from 0 up to PHASHRANGE - 1
	}
	
}
