package org.fabri1983.eternity2.core.mph;

/**
 * This class generated manually from the output algorithm in phash.c produced by the 
 * Bob Jenkins' Minimal Perfect Hash function algorithm, taking as input the misc/super_matriz_decimal.txt file.
 * See README.md file on how to generate that function.
 * 
 * PHASHRANGE - 1 is the greatest value produced by phash(), for the number of provided keys, which means super_matriz[] size must be PHASHRANGE.
 */
public class PerfectHashFunction2Interior {

	public static final int PHASHRANGE = 8192;
	
	// PHASHLEN 0x200 = 512
	static short tab[] = { 4064, 7733, 1206, 6454, 5345, 7452, 5985, 6255, 6675, 1785, 1334, 5586, 4400, 2464, 4064,
			3050, 6321, 5412, 6543, 6904, 3303, 7966, 12, 6910, 7017, 2987, 6799, 5693, 2517, 7646, 5361, 562, 3210,
			3584, 2139, 7745, 7086, 4672, 6383, 2976, 6834, 3879, 322, 3083, 3295, 2171, 747, 5499, 6999, 218, 4042,
			2465, 3325, 3419, 3452, 6110, 5311, 107, 330, 3210, 6383, 1403, 5196, 5890, 6675, 3969, 1334, 2840, 3889,
			67, 2906, 5311, 706, 3229, 4099, 2546, 4491, 522, 6921, 4368, 6383, 7017, 7414, 3816, 6601, 7668, 5913,
			3071, 3050, 508, 7516, 359, 3579, 1905, 5615, 6849, 3210, 532, 4303, 7452, 5225, 3879, 1679, 3913, 684,
			2478, 1905, 578, 5325, 4099, 4986, 1810, 4974, 3680, 5862, 5743, 2199, 578, 4600, 5499, 2224, 3850, 7891,
			2987, 5663, 992, 8166, 0, 2987, 5013, 4027, 2442, 423, 7745, 3155, 4491, 1723, 7146, 7425, 532, 6675, 0,
			190, 1210, 4400, 2794, 8034, 3950, 4813, 1905, 2822, 5743, 107, 3465, 522, 5325, 7672, 4901, 896, 3933,
			6562, 2110, 6849, 5389, 5930, 2465, 7784, 2502, 639, 1905, 7622, 578, 4164, 3210, 5562, 1403, 4600, 4942,
			5325, 322, 3386, 5127, 3290, 5712, 1057, 144, 1766, 4529, 2918, 6510, 1192, 6967, 7535, 7687, 4710, 684,
			1533, 3822, 5890, 8070, 0, 5628, 5541, 7051, 5534, 3969, 0, 1192, 3842, 5499, 2518, 7571, 6322, 2794, 6576,
			5013, 2947, 1896, 8103, 4064, 2883, 6663, 5774, 3290, 6026, 1733, 6878, 3123, 2679, 992, 6029, 1968, 4303,
			1146, 7425, 7452, 3056, 1194, 3889, 6571, 7646, 4197, 7077, 3689, 5389, 2689, 1232, 3579, 516, 747, 6807,
			4541, 3141, 5320, 6837, 4813, 522, 5033, 2139, 4164, 7516, 8044, 2472, 3969, 2918, 5512, 1232, 7250, 6910,
			1785, 6904, 5498, 2798, 516, 3120, 7134, 1533, 3210, 5522, 322, 4529, 6383, 2918, 1146, 1570, 2400, 843,
			2822, 6194, 2021, 5905, 4319, 7006, 5881, 157, 3987, 4400, 4813, 7452, 7992, 4710, 5512, 4491, 4055, 2820,
			3405, 522, 2435, 3584, 4099, 3823, 2918, 7086, 1449, 1533, 8070, 1621, 6921, 7490, 592, 5628, 4942, 1905,
			922, 5499, 6283, 6917, 1480, 532, 592, 1382, 6383, 1403, 3017, 2280, 5355, 7452, 7414, 1905, 7992, 3338,
			3699, 795, 6856, 1403, 2794, 8190, 330, 2209, 190, 6601, 4671, 4949, 657, 2295, 7598, 508, 3288, 4115, 5151,
			6613, 578, 293, 489, 8070, 992, 6029, 2653, 4922, 7622, 7425, 3056, 2110, 3545, 7841, 7672, 3499, 3669,
			7164, 7507, 311, 2028, 4303, 1041, 3056, 4055, 5169, 7634, 2600, 642, 6743, 1810, 5439, 4099, 5952, 5650,
			2343, 4751, 5452, 131, 6849, 6675, 6863, 4813, 1679, 6651, 3275, 3259, 2820, 7516, 4262, 7646, 1905, 7425,
			4481, 2518, 5743, 357, 3950, 330, 4901, 6788, 7585, 6159, 6004, 2209, 5779, 3845, 8073, 6995, 5196, 5811,
			7377, 7907, 3921, 1905, 3507, 2903, 2864, 6576, 0, 2546, 3201, 6878, 6458, 5345, 8070, 1403, 5355, 522,
			5156, 7592, 12, 6383, 508, 926, 2379, 1622, 3259, 183, 7781, 4610, 944, 5100, 6675, 5586, 6159, 4549, 7017,
			7077, 5336, 4143, 322, 0, 5866, 3969, 7414, 1570, 2442, 5628, 1896, 2525, 4564, 2918, 1199, 2572, 4491,
			2987, 3465, 795, 487, 5000, 1781, 1814, 6636, 1810, 2916, 6977, 4474, 5978, 1377, 8015, 218, 3083, 1723,
			5774, 3304, 4099, 7925, 4055, 5663, 5871 };

	public static int phash(int val) {
		// NOTE: in Java remember to replace >> by >>> to avoid carrying out the bit sign when you know some operations exceed 2^31 - 1
		// I decided to use >>> to always avoid carrying out the sign.
		
		val += 0xdc6d87dd; // PHASHSALT 0xdc6d87dd (31 bits!)
		val ^= (val >>> 16);
		
		/**
		 * IMPORTANT: val += (val << 8)
		 *  val << 8   This exceeds 31 bits for some values of val, and I suspect is down casted to int losing higher 32+ bits (if no later on).
		 *  val += ... This sum and assignment exceeds 31 bits as per before, and might be down casted twice: first at sum result and then at assignment step.
		 * 
		 * However this behavior works fine and produces correct results.
		 */
		val += (val << 8);
		
		val ^= (val >>> 4);
		int b = (val >>> 8) & 0x1ff; // 0x1ff = 511 => & 0x1ff is the fastest way of doing % 0x200 (PHASHLEN 512)
		int a = (val + (val << 2)) >>> 19;
		int rsl = (a ^ tab[b]);
		return rsl; // from 1 up to PHASHRANGE - 1
	}
	
}
