package org.fabri1983.eternity2.core;

public final class CompressedKeyArray {

	/**
	 * Creates an array of ints where each position corresponds to a valid color between 0..maxColores.
	 * Value of maxColores is also considered so the array is created with length = maxColores + 1.
	 * Each position will store a byte (as an int) of an address (int) sliced in 4 bytes. 
	 * 
	 * Then it loads all the keys as in file misc/super_matriz_indexes.txt starting from index 1.
	 * Each index will point to a position in NodoPosibles[6954].
	 * 
	 * @return the int[] array with the compressed keys pointing already to indexes for NodoPosibles[6954]
	 */
	public static final int[] setupRootIndexer(int maxColores) {
		// +1 because maxColores is also considered in the generation of the keys generated by combination of top,right,bottom,left.
		int[] rootIndexer = new int[maxColores + 1];
		
		// itero sobre todos las keys de misc/super_matriz_indexes.txt y por cada una de ellas revierto a su forma 
		// [top, right, bottom, left] para luego generar el compressed address.
		int[] keys = loadKeys();
		for (int i = 0, c = keys.length; i < c; ++i) {
			
			int key = keys[i];
			
			// revert key to tuple form [top, right, bottom, left]
			byte top = NodoPosibles.getTop(key);
			byte right = NodoPosibles.getRight(key);
			byte bottom = NodoPosibles.getBottom(key);
			byte left = NodoPosibles.getLeft(key);
			
			// now set the value of i as a compressed key formed by the tuple [top, right, bottom, left]
			addAddressTo(top, right, bottom, left, rootIndexer, i);
		}
		
		return rootIndexer;
	}
	
	/**
	 * Guarda la direccion key de 32 bits (int) dividida en 4 partes de 8 bits each en compressedKeyArray 
	 * en las diferentes posiciones dadas por top, right, bottom, y left.
	 * No se aplica shifting dado que las partes obtenidas de la key con & ya tiene las posiciones 
	 * de los bits correctas en el contexto de 32 bits.
	 */
	public static final void addAddressTo (final byte top, final byte right, final byte bottom, final byte left, 
			int[] compressedKeyArray, int key)
	{
		// NOTE: next tip is not valid anymore because the array HAS TO BE int[] type since no shifting is applied 
		// when storing a key.
		//
		// Si compressedKeyArray fuera de tipo bytes[] entonces tendría q usar >> así:
		//   para top: (byte) (address >> 24)
		//   para right: (byte) (address >> 16)
		//   para bottom: (byte) (address >> 8)
		//   para left: (byte) (address >> 0)
		//   No haría falta aplicar & porque luego del >> el casting a byte me toma los primeros 8 bits
		
		compressedKeyArray[top] = key & 0xFF000000; // me quedo con los bits 31..24
		compressedKeyArray[right] = key & 0xFF0000; // me quedo con los bits 23..16
		compressedKeyArray[bottom] = key & 0xFF00;  // me quedo con los bits 15..8
		compressedKeyArray[left] = key & 0xFF;      // me quedo con los bits  7..0
	}
	
	/**
	 * Devuelve la key de 32 bits (int) guardada en compressedKeyArray[] para esa combinación de colores.
	 * 
	 * @return 0 si no se ha guardado key con esa combinación de colores.
	 */
	public static final int getAddressFrom (final byte top, final byte right, final byte bottom, final byte left, 
			int[] compressedKeyArray)
	{
		// NOTE: next tip is not valid anymore because the array HAS TO BE int[] type since no shifting is applied 
		// when storing a key.
		//
		// Si compressedKeyArray fuera de tipo bytes[] entonces tendría q usar << así:
		//  compressedKeyArray[top] << 24
		//  compressedKeyArray[right] << 16
		//  compressedKeyArray[bottom] << 8
		//  compressedKeyArray[left] << 0
		//  No haría falta aplicar & porque el << me completa deja 0s a la derecha
		
		int address = compressedKeyArray[top] // address bits 31..24
				| compressedKeyArray[right]   // address bits 23..16
				| compressedKeyArray[bottom]  // address bits 15..8
				| compressedKeyArray[left];   // address bits  7..0
									          // Nota: no uso << ni & porque los bits ya estan en su lugar correcto en el contexto de 32 bits.
		return address;
	}

	private static int[] loadKeys() {
		int[] keys = new int[6954];
		
		return keys;
	}
	
}
