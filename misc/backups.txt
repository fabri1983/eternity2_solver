	/**
	 * Dada la posicion de cursor se fija qué colores tiene alrededor y devuelve una referencia de NodoPosibles 
	 * que contiene las piezas que cumplan con los colores en el orden top-right-bottom-left (sentido horario). 
	 * ## NOTA ## saqué muchas sentencias porque solamente voy a tener una pieza fija (en la pos 135), por eso 
	 * este metodo solo contempla las piezas top y left, salvo en el vecindario de la pieza fija. 
	 */
	public final static NodoPosibles obtenerPosiblesPiezas ()
	{
		switch (cursor)
		{
		//pregunto si me encuentro en la posicion inmediatamente arriba de la posicion central
		case SOBRE_POSICION_CENTRAL:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = pzxc.top;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//pregunto si me encuentro en la posicion inmediatamente a la izq de la posicion central
		case ANTE_POSICION_CENTRAL:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = pzxc.left;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		}
		
		switch (matrix_zonas[cursor])
		{
		//borde right
		case F_BORDE_RIGHT:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = GRIS;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//borde left
		case F_BORDE_LEFT:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = GRIS;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//posicion interior
		case F_INTERIOR:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//borde bottom
		case F_BORDE_BOTTOM:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = GRIS;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//esquina top-left
		case F_ESQ_TOP_LEFT:
			mapArrColours[0] = GRIS;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = GRIS;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//esquina top-right
		case F_ESQ_TOP_RIGHT:
			mapArrColours[0] = GRIS;
			mapArrColours[1] = GRIS;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//esquina bottom-right
		case F_ESQ_BOTTOM_RIGHT:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = GRIS;
			mapArrColours[2] = GRIS;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//esquina bottom-left
		case F_ESQ_BOTTOM_LEFT:
			mapArrColours[0] = tablero[cursor-LADO].bottom;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = GRIS;
			mapArrColours[3] = GRIS;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		//borde top (es la única posición que me faltaba preguntar)
		default:
			mapArrColours[0] = GRIS;
			mapArrColours[1] = MAX_COLORES;
			mapArrColours[2] = MAX_COLORES;
			mapArrColours[3] = tablero[cursor-1].right;
			return super_matriz[MapaKeys.getKeyArr4(mapArrColours)];
		}
	}
