TODO
- Pasar la divisin de tareas de SolverFasterMPJE a SolverFaster.
- En ExploracionAction hacer todo no static.
- Guardar pos_multi_process_offset en archivo status. Y setearlo cuando se lee el archivo.
- Guardar num_processes_orig[] en archivo status. Y setearlo cuando se lee el archivo. 
- Para jrockit usar la lib rt.jar que viene con esa JVM. Definir en el cada perfil su path

---------------------------------------------------------------------------------------
Fork/Join approach
------------------
Uso de un ForkJoinPool executor que ejecuta instancias de RecursiveAction (RecursiveAction no retorna valor).
ExploracionAction por el momento no usa fork, por lo que siempre existir谩 una cantidad fija de actions.
Esta decisi贸n es porque cada action creada va a ejecutar una rama del arbol de exploracion a partir de cierta posici贸n.
Aqui la l贸gica es la misma que la usada en SolverMPJE.
Asique la logica de qu茅 rama atacar es inherente al solver cuando se usa un approach de procesamiento paralelo.
Se decide a partir de una posici贸n seteada por configuraci贸n.

Ya que las diferentes actions utilizan a SolverFaster como shared resource, se presentan puntos de sincronizaci贸n:
  PUsada
  etc
Por eso utilizar CAS para cuando se desea modificar el estado de esos objetos.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
For including the jsr166 implementation jar, add next line to the VM arguments. 

	-Xbootclasspath/p:external-libs/jsr166.jar
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Optimizaciones:
---------------
- Modulo operation X % Y.
The clever optimisation is to use the bitwise AND operation which eliminates the use of loops and is a very fast CPU operation.
It requires that your modulo divisor is a power of 2 but if your code can support this then here is the method:

	public final static int fastModulo(int dividend, int divisor)
	{
	   return dividend & (divisor - 1);
	}

- Usar java.nio buffers puede agilizar el acceso. No se a partir de que version de JVM.
We need to use direct NIO buffers instead of arrays, but HotSpot can access direct NIO buffers as fast as arrays (http://blog.vlad1.com/2011/10/05/looking-at-java-nio-buffer-performance/).
De donde saqu茅 la idea: http://stackoverflow.com/questions/10784951/do-any-jvms-jit-compilers-generate-code-that-uses-vectorized-floating-point-ins
Example: http://www.java-gaming.org/index.php?PHPSESSID=2ftumjcjo00el2q4vs28louqj5&topic=12346.msg98913#msg98913

- no usar volatile para estructuras que se acceden por varios threads. Volatile fuerza que todos los 
threads siempre vean la 煤ltima modificaci贸n de la variable, lo que significa una especie de sincronizaci贸n impl铆cita.

- Cambiar las comparaciones y comparaci贸n/asignaci贸n de numeros por operadores de bit.
Ej:
	if (x == a) x= b;
  	else x= a;

	x= a ^ b ^ x; //where x is equal to either a or b

- Cada vez que se crea un arreglo este se inicializa en tiempo de ejecuci贸n. Entonces cada vez
que se invoca un metodo que crea un arreglo local se est贸 perdiendo tiempo en incializacion. 
Lo mejor es crearlo como static.

- Usar variables int en vez de short o byte. Java est谩 optimizado para int.
Care when using byte, short and char: When stored in a variable, built in types like byte, short, 
char and boolean all are represented as 32 bit values just like int and also use the same bytecode 
for loading and storing. The differerence in the memory used comes only when these built in types 
are stored in arrays. When stored in arrays, boolean and byte values are stored as 8-bit values, 
while short and char values are stored as 16-bit values.
Note that int, float, and object reference values are always stored as 32-bits each, and long and 
double values are always stored as 64-bit values.
The fastest types of variables are int and reference variables. This is because all operations on 
byte, short, and char are performed as ints, and assigning the results to a variable of the 
corresponding type requires an explicit cast.

- Usar menos llamadas de funciones porque provocan overhead de invocaci贸n.

- Strength reduction
Strength reduction occurs when an operation is replaced by an equivalent operation that executes faster. 
The most common example of strength reduction is using the shift operator to multiply and divide 
integers by a power of 2. For example, x >> 2 can be used in place of x / 4, and x << 1 replaces x * 2. 

- The first rule is to use a local int variable for the loop counter: for (int i=0;...).

- Rather than comparing i against N at each iteration, which requires N to be loaded 
(assuming N isn't a constant or static final variable), restructure the loop to take advantage 
of the efficient checks against 0. Comparing against zero is almost always more efficient in any 
language since the underlying tests are based on < 0, <= 0, == 0, != 0, >= 0 and > 0. 
To optimize, restructure the loop as:
	for (i = N; --i >= 0; ) {
	    // do something
	}
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
C贸digo comentado:
-----------------
- se coment贸 el uso de desde_saved[] porque ahora se calcula cuando se guarda estado.
- se coment贸 todo el uso de retroceder y cursor <= cursor_invalido (@RETROCEDER).
- se coment贸 el uso de poda contorno inferior en SolverFaster.java y Contorno.java (@CONTORNO_INFERIOR).
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Variable pos de class Pieza
---------------------------
Se coment贸 esta variable para asi ahorrar un poquito de espacio en memoria.
Si se llega a necesitar ser谩 necesario utilizarla de la misma manera que es empleada la class PUsada.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Tips && Notes
-------------

- Usar enum para los flags. Es mas r谩pido para procesar los switch-case.
Link: http://stackoverflow.com/questions/4922932/java-performance-of-enums-vs-if-then-else 

- Acotar pila de llamadas: una vez que paso cierta posici贸n (por ejemplo la 70) puedo hacer lo mismo
que cuando se carga estado para no tener en la pila 70 instancias que se que no voy a modificar en mucho tiempo.

- Cu谩ntas combinaciones voy realizando teniendo en cuenta todo el arbol de exploraci贸n?
En cada posici贸n cuando obtengo la lista de posibles piezas desde super_matriz[] estoy acotando las posibles ramas 
por las que me puedo ir. 
Cuando podo en la posici贸n cursor estoy descartando: 
	corner_libres! * edges_libres! * (inner_libres - hints)! * 4^(inner_libres - hints)

- Cantidad de nodos visitados:
Un nodo es una ubicaci贸n del arbol de exploraci贸n. En cada nodo puedo elegir varias piezas.
Entonces es contabilizar las piezas que voy probando.
Lo siguiente es extracto del yahoo grupo:

	If you download eternityIIJavaV0.8.zip from the file area (doc_smith
	folder) and check SimpleSearch.java method solve() you may get an idea.
	
	_numNodes++;
	counts the overall nodes
	
	_counts[depth]++;
	counts the nodes at each individual search depth.

- Max lenghts de objetos super_matriz[].referencias[] y sus ocurrencias de lenghts:
Max length: 64
1  - 4936 --> significa que hay 4936 arreglos referencias[] de longitud 1
2  - 806
3  - 488
4  - 346
5  - 164
6  - 56
7  - 20
8  - 6
12 - 40
24 - 20
46 - 4
47 - 4
48 - 12
49 - 4
50 - 44
64 - 4

- Usando super_matriz[] calcul茅 que existen como m谩ximo 7 piezas interiores (incluyendo las rotadas) para combinaci贸n de 
2, 3, y 4 colores consecutivos. Y 4 piezas restantes incluyendo rotadas para borde/esquina.
Conclusi贸n:
	en cada posici贸n de cursor donde necesite satisfacer combinaci贸n left-top voy a tener 4 posibles ramas para 
	borde/esquina y 7 posibles ramas para interior. Para el caso de la pieza central (sin tener en cuenta sus 
	rotaciones) se tienen 2 piezas para left-top-bottom y 2 piezas para left-top-right.
	Por lo tanto el tope de combinaciones ser谩: 4! * 4^56 * 7^194 * 2 * 2 = 3.1027626162141529951217613235866E+200
	Pero... no siempre voy a probar las 4 piezas en cada posici贸n de borde ni tampoco las 7 piezas en cada 
	posici贸n interior. Adem谩s el uso de contorno_sup en el interior del tablero hace que una combinaci贸n dada 
	left-top-top se pueda usar una sola vez.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
MPI
---
- Tomando como POSICION_MULTI_PROCESSES = 99 y rank 8 en laptop asus:

	Rank 1:    6391 ms, cursor 211
	Rank 1:  388315 ms, cursor 212
	old compu (phenom II x2): 
		- Rank 0: 2329734 ms, cursor 215

- Cuando inicio por primera vez se hace la sincronizaci贸n solo a fines de poder largar todos los procesos 
a la vez. Si se carga estado no se debe sincronizar pues cada proceso ya sabe qu茅 parte del arbol tomar.
Esto me brinda poder salvar N archivos de estado para luego dispersarlos y continuar la exploracion 
sin tener que esperar que los procesos dispersos se sincronicen.

- L贸gica de ataque de procesadores idle:
(Esta l贸gica viene inherente en el algoritmo de exploraci贸n)
Si el n煤mero de procesadores o nodos distribuidos es mayor a las ramas a explorar en POSICION_MULTI_PROCESSES => habr谩 
procesadores idle. La siguiente l贸gica "reparte" trabajo en varios niveles de profundidad:

  - decidir qu茅 rama tomar se refiere a definir los valores [desde,length_posibles] usados en exploracionStandard().
  - cada action se ocupa de 煤nicas ramas de exploracion de acuerdo a su id y el n煤mero de procesadores.
  - si se agregan/quitan nodos en tiempo de ejecuci贸n es probable algunas ramas se exploren de nuevo, ya que el 
  calculo de qu茅 rama tomar se estire o contraiga con le nuevo n煤mero de procesadores (de todas formas no pasa porque 
  la variable NUM_PROCESSES se define una 煤nica vez)
  - en el momento de decidir qu茅 rama explorar se tiene q tener en cuenta una vez salida de esa rama cu谩l ser铆a la 
  siguiente rama a explorar, y as铆 sucesivamente.

- Funcionamiento de la sincronizaci贸n:

  - Antes de llamar a exploracionStandard():

	if ((cursor == POSICION_MULTI_PROCESSES) && (sincronizar))
		sincronizar = false; //sincronizo una sola vez
		if (rank == 0)
			Send() a todos los procesos y esperar a que todos los recivan
		else
			Receive() sincr贸nico para que esperen el mensaje de rank(0)
		Esta logica esta implementada en metodo knocKnock()
  - Dentro de exploracionStandard():

	if (cursor == POSICION_MULTI_PROCESSES)
		establezco los limites del for. Aqui ir铆a la l贸gica de asignaci贸n de ramas en uno o mas niveles
		del arbol de exploraci贸n. 

- C贸mo comunico a los dem谩s procesos que se encontr贸 soluci贸n y mandarla para que todos se detengan? 
Desafortunadamente hacer llamadas Send y Receive dentro de un loop ocasionar铆a unexpected messages y si 
existen otras llamadas Send y Receive estas se cancelarian o se mezclar铆an con las anteriores.

- Qu茅 hacer si un proceso no encontr贸 soluci贸n?
Esto es important铆simo porque est谩 diciendo "no voy mas por esta rama porque conduce a nada". 
Tambien usar un thread que llame a MPI.Recv con ANY_SOURCE y TAG_NO_SOLUTION. 
Las ramas que ya no sirvan mas se pueden ir guardando en el archivo de estado al final y tener un 
procesamiento especial que evitara explorar dichas ramas. El problema es c贸mo almaceno una rama para 
luego saber que por ella no tengo que ir (lista de desde_saved?) 
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Filas precalculadas:
--------------------
- No se utiliza m谩s el arreglo de rotaciones en "posibles" por lo tanto hay que cambiar las comparaciones en FilaPiezas.

- El uso de pos_carga (cuando se calcula) genera un problema: es necesario setear como no usadas
las piezas en las posiciones de tablero que voy a usar, antes de colocar pieza alguna. Esto genera
un overhead. Sin dicha operaci贸n podr铆a setear como no usada una pieza que ya supon铆a usada (colocada
en posiciones anteriores).
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Contorno de piezas
------------------
- Idea:
Cada pieza ahora tiene su idUnico. Por lo tanto para un contorno de 2 columnas (left-top-top) dado existe un 
conjunto de tripletas de piezas irrepetibles seg煤n su idUnico. 
Ejemplo: para contorno 12-7-8 existen las tripletas (123,78,167); (99,101,452); etc. Estas tripletas apuntan al mismo contorno.
Ahora preguntar si un contorno est谩 usado es preguntarle a la referencia en cuesti贸n.
No s茅 si ser铆a mas r谩pido que lo actualmente implementado. Peeeeero... las tripletas que apuntan a ese contorno 
no pueden ser cargadas en tablero. Por lo que puedo tener un objeto PunteroContorno el cual contiene las 
tripletas a ese contorno. Si el puntero es usado entonces puedo evitar que se formen esas tripletas en tablero 
(muy costoso con el modelo de pieza unica actual).   

- Notas:
	* Usando solamente restricci贸n de contorno superior con 2 cols tardo 34.5 segs hasta la pos 211, cuando el 
	backtracker com煤n tarda 99 segs (mismo resultado en ambos casos!!).
	Pero para la posici贸n 209 tardaba 89 segs contra 43 segs del backtracker simple y no son los mismos resultados,
	por lo tanto usando contorno superior existe realmente una disminuci贸n del 谩rbol de exploraci贸n.
	Esto se deduce por el ordenamiento de las piezas y su acceso tambi锟n ordenado.
	
	* Usar mas de 2 columnas solamente me hace perder tiempo ya que alcanzo pos 211 con mismo resultado pero en 
	mayor tiempo. Me parece que esto es un hecho notable. Si con diferentes algoritmos llego a una misma posici贸n 
	por vez primera con mismo resultado todas ellas, entonces la de menor tiempo es la que logr贸 optimizar el recorrido.
	
	* Verificar: usar solamente contorno superior porque el uso de inferior ralentiza el backtracking y el 
	"benificio" del uso de contorno inferior es superado por la velocidad del backtracker. (HASTA AHORA 
	PARECE CIERTO, pero deber铆a tomar los tiempos en que tarda con y sin contorno inf hasta una posici贸n lejana).
	 
- As铆 tiene que ser:
	* Detectar los contornos superiores e inferiores en tablero de las piezas usadas.
	* Setear contorno usado se hace de dos maneras: superior e inferior. El superior se setea desde la fila 1
	(0-based) hasta la fila 14 (inclusive). El inferior se setea desde la fila 2 hasta fila 14 (inclusive).
	* La poda es preguntar si las celdas vacias que tengo que llenar tienen que formar un contorno ya usado.
	Entonces en explorar() cuando estoy en posici贸n adecuada pregunto si no existe contorno	superior usado.
	* Una vez que seleccion茅 pieza y la coloqu茅 en tablero[] pregunto si estoy en posici贸n adecuada y me 
	fijo si el contorno inferior que gener茅 no est谩 usado.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Supuestas piezas fijas:
----------------------
Las filas y columnas NO son 0-based. La rotaci贸n es 0-based

(num)	(fila)	(col)	(rotacion)	(rot original del chab贸n) 
208		3		3		1			(3)
181		14		3		1			(3)
139		9		8		0			(2)
255		3		14		1			(3)
249		14		14		2			(0)
---------------------------------------------------------------------------------------
