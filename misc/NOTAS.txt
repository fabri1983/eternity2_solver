TODO
- Pasar la división de tareas de SolverFasterMPJE a SolverFaster.
- En ExploracionAction hacer todo no static.
- Guardar pos_multi_process_offset en archivo status. Y setearlo cuando se lee el archivo.
- Guardar num_processes_orig[] en archivo status. Y setearlo cuando se lee el archivo. 
- Para jrockit usar la lib rt.jar que viene con esa JVM. Definir en el cada perfil su path

---------------------------------------------------------------------------------------
Fork/Join approach
------------------
Uso de un ForkJoinPool executor que ejecuta instancias de RecursiveAction (RecursiveAction no retorna valor).
ExploracionAction por el momento no usa fork, por lo que siempre existirá una cantidad fija de actions.
Esta decisión es porque cada action creada va a ejecutar una rama del arbol de exploracion a partir de cierta posición.
Aqui la lógica es la misma que la usada en SolverMPJE.
Asique la logica de qué rama atacar es inherente al solver cuando se usa un approach de procesamiento paralelo.
Se decide a partir de una posición seteada por configuración.

Ya que las diferentes actions utilizan a SolverFaster como shared resource, se presentan puntos de sincronización:
  PUsada
  etc
Por eso utilizar CAS para cuando se desea modificar el estado de esos objetos.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
For including the jsr166 implementation jar, add next line to the VM arguments. 

	-Xbootclasspath/p:external-libs/jsr166.jar
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Optimizaciones:
---------------
- Modulo operation X % Y.
The clever optimisation is to use the bitwise AND operation which eliminates the use of loops and is a very fast CPU operation.
It requires that your modulo divisor is a power of 2 but if your code can support this then here is the method:

	public final static int fastModulo(int dividend, int divisor)
	{
	   return dividend & (divisor - 1);
	}

- Usar java.nio buffers puede agilizar el acceso. No se a partir de que version de JVM.
We need to use direct NIO buffers instead of arrays, but HotSpot can access direct NIO buffers as fast as arrays (http://blog.vlad1.com/2011/10/05/looking-at-java-nio-buffer-performance/).
De donde saqué la idea: http://stackoverflow.com/questions/10784951/do-any-jvms-jit-compilers-generate-code-that-uses-vectorized-floating-point-ins
Example: http://www.java-gaming.org/index.php?PHPSESSID=2ftumjcjo00el2q4vs28louqj5&topic=12346.msg98913#msg98913

- no usar volatile para estructuras que se acceden por varios threads. Volatile fuerza que todos los 
threads siempre vean la última modificación de la variable, lo que significa una especie de sincronización implícita.

- Cambiar las comparaciones y comparación/asignación de numeros por operadores de bit.
Ej:
	if (x == a) x= b;
  	else x= a;

	x= a ^ b ^ x; //where x is equal to either a or b

- Cada vez que se crea un arreglo este se inicializa en tiempo de ejecución. Entonces cada vez
que se invoca un metodo que crea un arreglo local se estó perdiendo tiempo en incializacion. 
Lo mejor es crearlo como static.

- Usar variables int en vez de short o byte. Java está optimizado para int.
Care when using byte, short and char: When stored in a variable, built in types like byte, short, 
char and boolean all are represented as 32 bit values just like int and also use the same bytecode 
for loading and storing. The differerence in the memory used comes only when these built in types 
are stored in arrays. When stored in arrays, boolean and byte values are stored as 8-bit values, 
while short and char values are stored as 16-bit values.
Note that int, float, and object reference values are always stored as 32-bits each, and long and 
double values are always stored as 64-bit values.
The fastest types of variables are int and reference variables. This is because all operations on 
byte, short, and char are performed as ints, and assigning the results to a variable of the 
corresponding type requires an explicit cast.

- Usar menos llamadas de funciones porque provocan overhead de invocación.

- Strength reduction
Strength reduction occurs when an operation is replaced by an equivalent operation that executes faster. 
The most common example of strength reduction is using the shift operator to multiply and divide 
integers by a power of 2. For example, x >> 2 can be used in place of x / 4, and x << 1 replaces x * 2. 

- The first rule is to use a local int variable for the loop counter: for (int i=0;...).

- Rather than comparing i against N at each iteration, which requires N to be loaded 
(assuming N isn't a constant or static final variable), restructure the loop to take advantage 
of the efficient checks against 0. Comparing against zero is almost always more efficient in any 
language since the underlying tests are based on < 0, <= 0, == 0, != 0, >= 0 and > 0. 
To optimize, restructure the loop as:
	for (i = N; --i >= 0; ) {
	    // do something
	}
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Código comentado:
-----------------
- se comentó el uso de desde_saved[] porque ahora se calcula cuando se guarda estado.
- se comentó todo el uso de retroceder y cursor <= cursor_invalido (@RETROCEDER).
- se comentó el uso de poda contorno inferior en SolverFaster.java y Contorno.java (@CONTORNO_INFERIOR).
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Variable pos de class Pieza
---------------------------
Se comentó esta variable para asi ahorrar un poquito de espacio en memoria.
Si se llega a necesitar será necesario utilizarla de la misma manera que es empleada la class PUsada.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Tips && Notes
-------------

- Usar enum para los flags. Es mas rápido para procesar los switch-case.
Link: http://stackoverflow.com/questions/4922932/java-performance-of-enums-vs-if-then-else 

- Acotar pila de llamadas: una vez que paso cierta posición (por ejemplo la 70) puedo hacer lo mismo
que cuando se carga estado para no tener en la pila 70 instancias que se que no voy a modificar en mucho tiempo.

- Cuántas combinaciones voy realizando teniendo en cuenta todo el arbol de exploración?
En cada posición cuando obtengo la lista de posibles piezas desde super_matriz[] estoy acotando las posibles ramas 
por las que me puedo ir. 
Cuando podo en la posición cursor estoy descartando: 
	corner_libres! * edges_libres! * (inner_libres - hints)! * 4^(inner_libres - hints)

- Cantidad de nodos visitados:
Un nodo es una ubicación del arbol de exploración. En cada nodo puedo elegir varias piezas.
Entonces es contabilizar las piezas que voy probando.
Lo siguiente es extracto del yahoo grupo:

	If you download eternityIIJavaV0.8.zip from the file area (doc_smith
	folder) and check SimpleSearch.java method solve() you may get an idea.
	
	_numNodes++;
	counts the overall nodes
	
	_counts[depth]++;
	counts the nodes at each individual search depth.

- Max lenghts de objetos super_matriz[].referencias[] y sus ocurrencias de lenghts:
Max length: 64
1  - 4936 --> significa que hay 4936 arreglos referencias[] de longitud 1
2  - 806
3  - 488
4  - 346
5  - 164
6  - 56
7  - 20
8  - 6
12 - 40
24 - 20
46 - 4
47 - 4
48 - 12
49 - 4
50 - 44
64 - 4

- Usando super_matriz[] calculé que existen como máximo 7 piezas interiores (incluyendo las rotadas) para combinación de 
2, 3, y 4 colores consecutivos. Y 4 piezas restantes incluyendo rotadas para borde/esquina.
Conclusión:
	en cada posición de cursor donde necesite satisfacer combinación left-top voy a tener 4 posibles ramas para 
	borde/esquina y 7 posibles ramas para interior. Para el caso de la pieza central (sin tener en cuenta sus 
	rotaciones) se tienen 2 piezas para left-top-bottom y 2 piezas para left-top-right.
	Por lo tanto el tope de combinaciones será: 4! * 4^56 * 7^194 * 2 * 2 = 3.1027626162141529951217613235866E+200
	Pero... no siempre voy a probar las 4 piezas en cada posición de borde ni tampoco las 7 piezas en cada 
	posición interior. Además el uso de contorno_sup en el interior del tablero hace que una combinación dada 
	left-top-top se pueda usar una sola vez.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
MPI
---
- Tomando como POSICION_MULTI_PROCESSES = 99 y rank 8 en laptop asus:

	Rank 1:    6391 ms, cursor 211
	Rank 1:  388315 ms, cursor 212
	old compu (phenom II x2): 
		- Rank 0: 2329734 ms, cursor 215

- Cuando inicio por primera vez se hace la sincronización solo a fines de poder largar todos los procesos 
a la vez. Si se carga estado no se debe sincronizar pues cada proceso ya sabe qué parte del arbol tomar.
Esto me brinda poder salvar N archivos de estado para luego dispersarlos y continuar la exploracion 
sin tener que esperar que los procesos dispersos se sincronicen.

- Lógica de ataque de procesadores idle:
(Esta lógica viene inherente en el algoritmo de exploración)
Si el número de procesadores o nodos distribuidos es mayor a las ramas a explorar en POSICION_MULTI_PROCESSES => habrá 
procesadores idle. La siguiente lógica "reparte" trabajo en varios niveles de profundidad:

  - decidir qué rama tomar se refiere a definir los valores [desde,length_posibles] usados en exploracionStandard().
  - cada action se ocupa de únicas ramas de exploracion de acuerdo a su id y el número de procesadores.
  - si se agregan/quitan nodos en tiempo de ejecución es probable algunas ramas se exploren de nuevo, ya que el 
  calculo de qué rama tomar se estire o contraiga con le nuevo número de procesadores (de todas formas no pasa porque 
  la variable NUM_PROCESSES se define una única vez)
  - en el momento de decidir qué rama explorar se tiene q tener en cuenta una vez salida de esa rama cuál sería la 
  siguiente rama a explorar, y así sucesivamente.

- Funcionamiento de la sincronización:

  - Antes de llamar a exploracionStandard():

	if ((cursor == POSICION_MULTI_PROCESSES) && (sincronizar))
		sincronizar = false; //sincronizo una sola vez
		if (rank == 0)
			Send() a todos los procesos y esperar a que todos los recivan
		else
			Receive() sincrónico para que esperen el mensaje de rank(0)
		Esta logica esta implementada en metodo knocKnock()
  - Dentro de exploracionStandard():

	if (cursor == POSICION_MULTI_PROCESSES)
		establezco los limites del for. Aqui iría la lógica de asignación de ramas en uno o mas niveles
		del arbol de exploración. 

- Cómo comunico a los demás procesos que se encontró solución y mandarla para que todos se detengan? 
Desafortunadamente hacer llamadas Send y Receive dentro de un loop ocasionaría unexpected messages y si 
existen otras llamadas Send y Receive estas se cancelarian o se mezclarían con las anteriores.

- Qué hacer si un proceso no encontró solución?
Esto es importantísimo porque está diciendo "no voy mas por esta rama porque conduce a nada". 
Tambien usar un thread que llame a MPI.Recv con ANY_SOURCE y TAG_NO_SOLUTION. 
Las ramas que ya no sirvan mas se pueden ir guardando en el archivo de estado al final y tener un 
procesamiento especial que evitara explorar dichas ramas. El problema es cómo almaceno una rama para 
luego saber que por ella no tengo que ir (lista de desde_saved?) 
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Filas precalculadas:
--------------------
- No se utiliza más el arreglo de rotaciones en "posibles" por lo tanto hay que cambiar las comparaciones en FilaPiezas.

- El uso de pos_carga (cuando se calcula) genera un problema: es necesario setear como no usadas
las piezas en las posiciones de tablero que voy a usar, antes de colocar pieza alguna. Esto genera
un overhead. Sin dicha operación podría setear como no usada una pieza que ya suponía usada (colocada
en posiciones anteriores).
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Contorno de piezas
------------------
- Idea:
Cada pieza ahora tiene su idUnico. Por lo tanto para un contorno de 2 columnas (left-top-top) dado existe un 
conjunto de tripletas de piezas irrepetibles según su idUnico. 
Ejemplo: para contorno 12-7-8 existen las tripletas (123,78,167); (99,101,452); etc. Estas tripletas apuntan al mismo contorno.
Ahora preguntar si un contorno está usado es preguntarle a la referencia en cuestión.
No sé si sería mas rápido que lo actualmente implementado. Peeeeero... las tripletas que apuntan a ese contorno 
no pueden ser cargadas en tablero. Por lo que puedo tener un objeto PunteroContorno el cual contiene las 
tripletas a ese contorno. Si el puntero es usado entonces puedo evitar que se formen esas tripletas en tablero 
(muy costoso con el modelo de pieza unica actual).   

- Notas:
	* Usando solamente restricción de contorno superior con 2 cols tardo 34.5 segs hasta la pos 211, cuando el 
	backtracker común tarda 99 segs (mismo resultado en ambos casos!!).
	Pero para la posición 209 tardaba 89 segs contra 43 segs del backtracker simple y no son los mismos resultados,
	por lo tanto usando contorno superior existe realmente una disminución del árbol de exploración.
	Esto se deduce por el ordenamiento de las piezas y su acceso tambi�n ordenado.
	
	* Usar mas de 2 columnas solamente me hace perder tiempo ya que alcanzo pos 211 con mismo resultado pero en 
	mayor tiempo. Me parece que esto es un hecho notable. Si con diferentes algoritmos llego a una misma posición 
	por vez primera con mismo resultado todas ellas, entonces la de menor tiempo es la que logró optimizar el recorrido.
	
	* Verificar: usar solamente contorno superior porque el uso de inferior ralentiza el backtracking y el 
	"benificio" del uso de contorno inferior es superado por la velocidad del backtracker. (HASTA AHORA 
	PARECE CIERTO, pero debería tomar los tiempos en que tarda con y sin contorno inf hasta una posición lejana).
	 
- Así tiene que ser:
	* Detectar los contornos superiores e inferiores en tablero de las piezas usadas.
	* Setear contorno usado se hace de dos maneras: superior e inferior. El superior se setea desde la fila 1
	(0-based) hasta la fila 14 (inclusive). El inferior se setea desde la fila 2 hasta fila 14 (inclusive).
	* La poda es preguntar si las celdas vacias que tengo que llenar tienen que formar un contorno ya usado.
	Entonces en explorar() cuando estoy en posición adecuada pregunto si no existe contorno	superior usado.
	* Una vez que seleccioné pieza y la coloqué en tablero[] pregunto si estoy en posición adecuada y me 
	fijo si el contorno inferior que generé no está usado.
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
Supuestas piezas fijas:
----------------------
Las filas y columnas NO son 0-based. La rotación es 0-based

(num)	(fila)	(col)	(rotacion)	(rot original del chabón) 
208		3		3		1			(3)
181		14		3		1			(3)
139		9		8		0			(2)
255		3		14		1			(3)
249		14		14		2			(0)
---------------------------------------------------------------------------------------
